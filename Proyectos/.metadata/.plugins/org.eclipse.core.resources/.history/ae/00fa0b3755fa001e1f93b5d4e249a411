#include "MAX31865_lib.h"

#define MAX31865_PT100_R0 (double)100.0
#define MAX31865_Rref (double)428.5

#define MAX31865_A (double)0.0039083
#define MAX31865_B (double)0.0000005775

double MAX31865_PT100_R = 0.0;
double MAX31865_PT100_T = 0.0;
bool MAX31865_Sensor_Error = 0;

#define cs_set() CS_GPIO_Port-> BSRR = (uint32_t) CS_Pin << 16u;
#define cs_reset() CS_GPIO_Port ->BSRR = CS_Pin;
extern SPI_HandleTypeDef hspi1;

void MAX31865_Init(uint8_t num_wires) {
	uint8_t MAX31865_Reinitialization_cnt = 0;
	MAX31865_Sensor_Error = 0;
	uint8_t MAX31865_Configuration_register_write[] = { 0x80, 0x00 };

	if (num_wires == 2 || num_wires == 4) {
		MAX31865_Configuration_register_write[1] = 0xC3; //0xC3
	} else if (num_wires == 3) {
		MAX31865_Configuration_register_write[1] = 0xD3; //0xD3
	}
	cs_set();
	HAL_SPI_Transmit(&hspi1, MAX31865_Configuration_register_write, 2, 100);
	cs_reset();

	while (MAX31865_Configuration_info() != 0xD1
			&& MAX31865_Configuration_info() != 0xC1) {
		MAX31865_Reinitialization_cnt++;

		cs_set();
		HAL_SPI_Transmit(&hspi1, MAX31865_Configuration_register_write, 2, 100);
		cs_reset();

		if (MAX31865_Reinitialization_cnt == 100) {
			//printf("Initialization MAX31865 != OK\r\n");
			break;
		}

	}
}

uint8_t MAX31865_Configuration_info(void) {
	uint8_t read_data = 0x00;
	uint8_t MAX31865_Configuration = 0x00;
	cs_set();
	HAL_SPI_Transmit(&hspi1, &read_data, 1, 100);
	HAL_SPI_Receive(&hspi1, &MAX31865_Configuration, 1, 100);
	cs_reset();
	return MAX31865_Configuration;
}

double MAX31865_Get_Temperature(void);
double MAX31865_Get_Temperature_math(double PT100_Resistance);
